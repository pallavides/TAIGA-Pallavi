/*
 * fifo_queue.c
 *
 *  Created on: Mar 17, 2015
 *      Author: teja
 */

#include "fifo_queue.h"
#include "xstreamer.h"
#include "xil_cache.h"
#include "xstatus.h"
#include "axi_gpio.h"
#include "xintc.h"
#define INTC_DEVICE_ID	XPAR_INTC_0_DEVICE_ID

static XLlFifo fifo_enqueue;
static XLlFifo fifo_dequeue;

int init_fifo_queues(){

	XLlFifo_Config *Config;
	int Status;
	Status = XST_SUCCESS;

	// Initialize the Enqueue Module -----------------------------

	// Initialize the Device Configuration Interface driver
	Config = XLlFfio_LookupConfig(ENQUEUE_DEV_ID);
	if (!Config) {
		xil_printf("No config found for %d\r\n", ENQUEUE_DEV_ID);
		return XST_FAILURE;
	}

	// This is where the virtual address would be used, this example uses physical address.
	Status = XLlFifo_CfgInitialize(&fifo_enqueue, Config, Config->BaseAddress);
	if (Status != XST_SUCCESS) {
		xil_printf("Initialization failed\n\r");
		return Status;
	}

	// Check for the Reset value
	Status = XLlFifo_Status(&fifo_enqueue);
	XLlFifo_IntClear(&fifo_enqueue,0xffffffff);
	Status = XLlFifo_Status(&fifo_enqueue);
	if(Status != 0x0) {
		xil_printf("\n ERROR : Reset value of ISR0 : 0x%x\t" "Expected : 0x0\n\r", XLlFifo_Status(&fifo_enqueue));
		return XST_FAILURE;
	}

	// Initialize the Dequeue Module -----------------------------

	// Initialize the Device Configuration Interface driver
	Config = XLlFfio_LookupConfig(DEQUEUE_DEV_ID);
	if (!Config) {
		xil_printf("No config found for %d\r\n", DEQUEUE_DEV_ID);
		return XST_FAILURE;
	}

	// This is where the virtual address would be used, this example uses physical address.
	Status = XLlFifo_CfgInitialize(&fifo_dequeue, Config, Config->BaseAddress);
	if (Status != XST_SUCCESS) {
		xil_printf("Initialization failed\n\r");
		return Status;
	}

	// Check for the Reset value
	Status = XLlFifo_Status(&fifo_dequeue);
	XLlFifo_IntClear(&fifo_dequeue,0xffffffff);
	Status = XLlFifo_Status(&fifo_dequeue);
	if(Status != 0x0) {
		xil_printf("\n ERROR : Reset value of ISR0 : 0x%x\t" "Expected : 0x0\n\r", XLlFifo_Status(&fifo_dequeue));
		return XST_FAILURE;
	}

	init_interrupt_controller

	return XST_SUCCESS;
}

int enqueue(int* data, int size){
	int i = 0;
	for(i = 0; i < size; ++i){
		if( XLlFifo_iTxVacancy(&fifo_enqueue))
			XLlFifo_TxPutWord(&fifo_enqueue, data[i]);
	}

	// Start Transmission by writing transmission length into the TLR
	XLlFifo_iTxSetLen(&fifo_enqueue, WORD_SIZE*size);

	// Check for Transmission completion
	while( !(XLlFifo_IsTxDone(&fifo_enqueue)));

	return 0;
}

int dequeue(int* buffer){
	int ReceiveLength = 0;
	int RxWord = 0;

	ReceiveLength = (XLlFifo_iRxGetLen(&fifo_dequeue))/WORD_SIZE;

	if(sizeof(buffer)/WORD_SIZE < ReceiveLength)	return -1;

	int i = 0;
	// Start Receiving
	for ( i=0; i < ReceiveLength; i++){
		RxWord = 0;
		RxWord = XLlFifo_RxGetWord(&fifo_dequeue);
		buffer[i] = RxWord;
	}

	return ReceiveLength;
}

static XIntc interrupt_controller;

static void fifo_handler(XLlFifo *InstancePtr);

int init_interrupt_controller(){
	int Status;

	// Initialize the FIFO Interrupt -----------------------------

	// Initialize the interrupt controller driver so that it is ready to use.
	Status = XIntc_Initialize(&interrupt_controller, INTC_DEVICE_ID);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	// Connect a device driver handler that will be called when an interrupt occurs
	Status = XIntc_Connect(&interrupt_controller, FIFO_INTR_ID, (XInterruptHandler)fifo_handler, (void *)&fifo_dequeue);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	// Start the interrupt controller such that interrupts are enabled for all devices that cause interrupts
	Status = XIntc_Start(&interrupt_controller, XIN_REAL_MODE);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	// Enable the interrupt for the AXI FIFO device.
	XIntc_Enable(&interrupt_controller, FIFO_INTR_ID);

	// Initialize the exception table.
	Xil_ExceptionInit();

	// Register the interrupt controller handler with the exception table.
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XIntc_InterruptHandler, (void *)&interrupt_controller);;

	// Enable exceptions.
	Xil_ExceptionEnable();

	XLlFifo_IntEnable(&fifo_dequeue, XLLF_INT_ALL_MASK);
}

static void fifo_handler(XLlFifo *InstancePtr){
	u32 Pending;
	int buffer[20];

	Pending = XLlFifo_IntPending(InstancePtr);
	while (Pending) {
		static bool ledState = true;
		set_led(LED1, ledState);
		ledState = !ledState;
		if (Pending & XLLF_INT_RFPE_MASK) {
			//FifoRecvHandler(InstancePtr);
			dequeue(buffer);
			XLlFifo_IntClear(InstancePtr, XLLF_INT_RFPE_MASK);
			xil_printf("%dhi\n",buffer[0]);
		}
		else {
			XLlFifo_IntClear(InstancePtr, Pending);
		}
		Pending = XLlFifo_IntPending(InstancePtr);
	}
}
